/**
 *
 * Created by jogen on 16/7/25.
 */
exports.install = function (Vue, options = {}) {
    const DEFAULT = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUCB1jYGRk/A8AAQ0BA6VCjZAAAAAASUVORK5CYII='
    Vue.directive('lazy', {
        scrollEventTarget: null,
        loading: options.loading || DEFAULT,
        error: options.error || DEFAULT,
        lazyImages: new Set(),
        initial: false,

        //获取滚动事件目标元素
        getScrollEventTarget (element) {
            if (this.scrollEventTarget && !element) return this.scrollEventTarget
            let currentNode = element
            while (currentNode && currentNode.nodeType === 1 && currentNode.targetName !== 'HTML' && currentNode.targetName
            !== 'BODY') {
                let overflowY = document.defaultView.getComputedStyle(currentNode).overflowY
                if (overflowY === 'auto' || overflowY === 'scroll') {
                    return currentNode
                }
                currentNode = currentNode.parentNode
            }
            return window
        },

        // 获取当前图片的位置
        getCurrentImagePos (elem) {
            let positionY
            let viewTop = elem.getBoundingClientRect().top
            if (this.scrollEventTarget === window) { // div局部滚动还是body滚动
                positionY = viewTop + Math.max(document.documentElement.scrollTop, document.body.scrollTop)
            } else {
                positionY = viewTop + this.scrollEventTarget.scrollTop
            }
            return positionY
        },

        // 检查图片是否在屏幕内
        checkImageisView (item) {
            let scrollHeight
            if (this.scrollEventTarget === window) {
                scrollHeight = Math.max(window.pageYOffset || 0, document.documentElement.clientHeight) + Math.max(document.body.scrollTop, document.documentElement.scrollTop)
            } else {
                scrollHeight = this.scrollEventTarget.clientHeight + this.scrollEventTarget.scrollTop
            }
            if (item.y < scrollHeight) {
                this.replace(item)
            }
        },

        // 替换image src
        replace (item) {
            this.loadImageWithAsync(item).then((src) => {
                if (this.lazyImages.size > 0) this.lazyImages.delete(item)
                item.el.setAttribute('src', item.src)
                item.el.setAttribute('status', 'success')
            }).catch((src) => {
                item.el.setAttribute('src', item.error)
                item.el.setAttribute('status', 'filed')
            })
        },

        // 异步加载图片
        loadImageWithAsync (item) {
            return new Promise((resolve, reject) => {
                let Img = new Image()
                Img.src = item.src
                Img.onload = () => {
                    resolve(item.src)
                }
                Img.onerror = () => {
                    reject(new Error('无法加载这张图片') + item.src)
                }
            })
        },

        // 函数防抖
        debounce (context, delay) {
            let timer
            return () => {
                let args = arguments
                clearTimeout(timer)
                setTimeout(() => {
                    context.apply(this, args)
                })
            }
        },
        handleScrollEvent () {
            let self = this
            for (let item of self.lazyImages.keys()) {
                self.checkImageisView(item)
            }
        },
        bind () {
            let self = this
            if (!self.hasBind) {
                self.initial = true
                self.scrollEventTarget = self.getScrollEventTarget(this.el)
                this.scrollEventTarget.addEventListener('scroll', this.debounce(this.handleScrollEvent, 500))
            }
        },
        update (src) {
            let self = this
            self.el.setAttribute('status', 'loading')
            self.el.setAttribute('src', self.loading)
            self.vm.$nextTick(() => {
                let imagePos = self.getCurrentImagePos(self.el)
                self.lazyImages.add({
                    el: self.el,
                    src: src,
                    y: imagePos,
                })
                self.handleScrollEvent()
            })
        },
        unbind () {
            this.scrollEventTarget.removeEventListener('scroll', this.debounce(this.handleScrollEvent, 500))
        }
    })
}
