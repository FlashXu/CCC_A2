'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _VFragment = require('../../lib/VFragment');

var _VFragment2 = _interopRequireDefault(_VFragment);

var _lib = require('../../lib');

var _PropTypes = require('../../lib/PropTypes');

var _PopupContainer = require('./private/PopupContainer');

var _PopupContainer2 = _interopRequireDefault(_PopupContainer);

var _popupConstants = require('./private/popupConstants');

var _PopupHeader = require('./PopupHeader');

var _PopupHeader2 = _interopRequireDefault(_PopupHeader);

var _PopupContent = require('./PopupContent');

var _PopupContent2 = _interopRequireDefault(_PopupContent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HOVERABLE_BLUR_DELAY = 300;

exports.default = {
  name: 'SuiPopup',
  description: 'A popup displays additional information on top of a page.',
  mixins: [_lib.SemanticUIVueMixin],
  props: {
    basic: {
      type: Boolean,
      description: 'Display the popup without the pointing arrow.'
    },
    content: {
      type: String,
      description: 'Simple text content for the popover.'
    },
    flowing: {
      type: Boolean,
      description: 'A flowing Popup has no maximum width and continues to flow to fit its content.'
    },
    header: {
      type: String,
      description: 'Header displayed above the content in bold.'
    },
    hoverable: {
      type: Boolean,
      description: 'Whether the popup should not close on hover.'
    },
    inverted: {
      type: Boolean,
      description: 'Invert the colors of the Popup.'
    },
    position: (0, _PropTypes.Enum)(_popupConstants.POSITIONS, {
      description: 'Position for the popover.',
      default: 'top left'
    }),
    size: (0, _PropTypes.Enum)(['mini', 'tiny', 'small', 'large', 'huge'], {
      description: 'Popup size.'
    }),
    wide: (0, _PropTypes.Enum)(['wide'], {
      type: Boolean,
      description: 'Popup width.'
    })
  },
  data: function data() {
    return {
      coords: null,
      open: false
    };
  },
  mounted: function mounted() {
    this.$slots.trigger[0].elm.addEventListener('mouseenter', this.handleOpen);
    this.$slots.trigger[0].elm.addEventListener('mouseleave', this.handleBlur);
  },

  methods: {
    handleOpen: function handleOpen() {
      this.coords = this.$slots.trigger[0].elm.getBoundingClientRect();
      this.open = true;
    },
    handleBlur: function handleBlur() {
      if (this.hoverable) {
        this.blurTimeout = setTimeout(this.close, HOVERABLE_BLUR_DELAY);
      } else {
        this.close();
      }
    },
    handleContainerHover: function handleContainerHover() {
      if (this.hoverable && this.blurTimeout) {
        clearTimeout(this.blurTimeout);
      }
    },
    close: function close() {
      this.open = false;
    }
  },
  render: function render() {
    var h = arguments[0];

    return h(
      _VFragment2.default,
      null,
      [this.$slots.trigger, this.open && h(
        _PopupContainer2.default,
        {
          on: {
            'mouseover': this.handleContainerHover,
            'mouseleave': this.handleBlur
          },
          attrs: {
            popupClass: this.classes(this.basic && 'basic', this.flowing && 'flowing', this.inverted && 'inverted', this.size, this.wide, this.wide && 'wide'),
            triggerCoords: this.coords,
            position: this.position
          }
        },
        [this.header && h(
          _PopupHeader2.default,
          null,
          [this.header]
        ), this.content && h(
          _PopupContent2.default,
          null,
          [this.content]
        ), this.$slots.default]
      )]
    );
  }
};