'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mapValues = require('lodash/mapValues');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _without = require('lodash/without');

var _without2 = _interopRequireDefault(_without);

var _lib = require('../../../lib');

var _popupConstants = require('./popupConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'SuiPrivatePopupContainer',
  mixins: [_lib.SemanticUIVueMixin],
  props: {
    popupClass: String,
    triggerCoords: _lib.isBrowser ? [window.DOMRect, Object] : Object,
    position: String
  },
  data: function data() {
    return {
      mountedPosition: this.position,
      mountedStyle: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.popupCoords = _this.$refs.container.getBoundingClientRect();
      _this.setPopupStyle();
    });
  },

  methods: {
    computePopupStyle: function computePopupStyle(positions) {
      var style = { position: 'absolute' };

      // Do not access window/document when server side rendering
      if (!_lib.isBrowser) return style;

      var offset = this.offset;
      var _window = window,
          pageYOffset = _window.pageYOffset,
          pageXOffset = _window.pageXOffset;
      var _document$documentEle = document.documentElement,
          clientWidth = _document$documentEle.clientWidth,
          clientHeight = _document$documentEle.clientHeight;


      if (positions.includes('right')) {
        style.right = Math.round(clientWidth - (this.triggerCoords.right + pageXOffset));
        style.left = 'auto';
      } else if (positions.includes('left')) {
        style.left = Math.round(this.triggerCoords.left + pageXOffset);
        style.right = 'auto';
      } else {
        // if not left nor right, we are horizontally centering the element
        var xOffset = (this.triggerCoords.width - this.popupCoords.width) / 2;
        style.left = Math.round(this.triggerCoords.left + xOffset + pageXOffset);
        style.right = 'auto';
      }

      if (positions.includes('top')) {
        style.bottom = Math.round(clientHeight - (this.triggerCoords.top + pageYOffset));
        style.top = 'auto';
      } else if (positions.includes('bottom')) {
        style.top = Math.round(this.triggerCoords.bottom + pageYOffset);
        style.bottom = 'auto';
      } else {
        // if not top nor bottom, we are vertically centering the element
        var yOffset = (this.triggerCoords.height + this.popupCoords.height) / 2;
        style.top = Math.round(this.triggerCoords.bottom + pageYOffset - yOffset);
        style.bottom = 'auto';

        var _xOffset = this.popupCoords.width + 8;
        if (positions.includes('right')) {
          style.right -= _xOffset;
        } else {
          style.left -= _xOffset;
        }
      }

      if (offset) {
        if (typeof style.right === 'number') {
          style.right -= offset;
        } else {
          style.left -= offset;
        }
      }

      return style;
    },
    isStyleInViewport: function isStyleInViewport(style) {
      var _window2 = window,
          pageYOffset = _window2.pageYOffset,
          pageXOffset = _window2.pageXOffset;
      var _document$documentEle2 = document.documentElement,
          clientWidth = _document$documentEle2.clientWidth,
          clientHeight = _document$documentEle2.clientHeight;


      var element = {
        top: style.top,
        left: style.left,
        width: this.popupCoords.width,
        height: this.popupCoords.height
      };

      if (typeof style.right === 'number') {
        element.left = clientWidth - style.right - element.width;
      }
      if (typeof style.bottom === 'number') {
        element.top = clientHeight - style.bottom - element.height;
      }

      // hidden on top
      if (element.top < pageYOffset) return false;
      // hidden on the bottom
      if (element.top + element.height > pageYOffset + clientHeight) return false;
      // hidden the left
      if (element.left < pageXOffset) return false;
      // hidden on the right
      if (element.left + element.width > pageXOffset + clientWidth) return false;

      return true;
    },
    setPopupStyle: function setPopupStyle() {
      if (!this.triggerCoords || !this.popupCoords) return;
      var position = this.position;

      var style = this.computePopupStyle(position);

      // Lets detect if the popup is out of the viewport and adjust
      // the position accordingly
      var positions = (0, _without2.default)(_popupConstants.POSITIONS, position).concat([position]);
      for (var i = 0; !this.isStyleInViewport(style) && i < positions.length; i += 1) {
        style = this.computePopupStyle(positions[i]);
        position = positions[i];
      }

      // Append 'px' to every numerical values in the style
      style = (0, _mapValues2.default)(style, function (value) {
        return typeof value === 'number' ? value + 'px' : value;
      });
      this.mountedStyle = style;
      this.mountedPosition = position;
    }
  },
  render: function render() {
    var _this2 = this;

    var h = arguments[0];

    var className = this.classes('ui', this.mountedPosition, this.popupClass, 'popup', 'transition visible');

    return h(
      'portal',
      {
        attrs: { to: 'semantic-ui-vue' }
      },
      [h(
        'div',
        {
          ref: 'container',
          'class': className,
          style: this.mountedStyle,
          on: {
            'mouseover': function mouseover() {
              return _this2.$emit('mouseover');
            },
            'mouseleave': function mouseleave() {
              return _this2.$emit('mouseleave');
            }
          }
        },
        [this.$slots.default]
      )]
    );
  }
};